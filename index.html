<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Poppins:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <title>Simula√ß√£o de Aloca√ß√£o de Mem√≥ria RAM</title>
    <style>
      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, system-ui,
          sans-serif;
        background: #000000;
        color: rgba(255, 255, 255, 0.92);
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 40px 20px;
        min-height: 100vh;
        margin: 0;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      h2 {
        color: rgba(255, 255, 255, 0.95);
        font-size: 2.125rem;
        font-weight: 700;
        letter-spacing: -0.022em;
        margin-bottom: 1.5rem;
        text-align: center;
        line-height: 1.2;
        font-family: "Poppins", sans-serif;
      }

      #animation-container {
        display: flex;
        gap: 32px;
        width: 100%;
        max-width: 1200px;
        justify-content: center;
        align-items: stretch;
        height: 600px;
      }

      /* Coluna da RAM */
      #ram-container {
        flex-basis: 50%;
        display: flex;
        flex-direction: column;
      }

      #ram {
        display: flex;
        flex-wrap: wrap;
        border: none;
        background: rgba(30, 30, 30, 0.7);
        backdrop-filter: blur(20px) saturate(180%);
        padding: 20px;
        width: 100%;
        max-width: 500px;
        border-radius: 16px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.1);
        flex: 1;
        align-content: flex-start;
        justify-content: flex-start;
      }

      .memory-cell {
        width: 85px;
        height: 70px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        margin: 5px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        font-size: 10px;
        transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }

      .memory-cell .address {
        font-weight: 500;
        color: rgba(255, 255, 255, 0.4);
        padding: 6px;
        font-family: "IBM Plex Mono", "SF Mono", "Monaco", "Menlo", monospace;
        font-size: 9px;
        background: rgba(255, 255, 255, 0.03);
        border-radius: 6px 6px 0 0;
        letter-spacing: -0.03em;
      }

      .memory-cell .value {
        font-size: 1.8em;
        font-weight: 600;
        text-align: center;
        padding-bottom: 6px;
        color: rgba(255, 255, 255, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
      }

      /* Estados da Mem√≥ria */
      .memory-cell.free {
        background: rgba(255, 255, 255, 0.03);
        border-color: rgba(255, 255, 255, 0.08);
      }

      .memory-cell.system {
        background: rgba(142, 142, 147, 0.15);
        border-color: rgba(142, 142, 147, 0.4);
        border-width: 1px;
        box-shadow: 0 4px 16px rgba(142, 142, 147, 0.15),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
      }

      .memory-cell.allocated {
        background: rgba(0, 122, 255, 0.15);
        border-color: rgba(0, 122, 255, 0.4);
        border-width: 1px;
        box-shadow: 0 4px 16px rgba(0, 122, 255, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
        transform: translateY(-1px);
      }

      .memory-cell.highlighted {
        background: rgba(255, 149, 0, 0.2);
        border-color: rgba(255, 149, 0, 0.6);
        border-width: 2px;
        transform: scale(1.05) translateY(-2px);
        box-shadow: 0 8px 24px rgba(255, 149, 0, 0.3),
          inset 0 1px 0 rgba(255, 255, 255, 0.2);
        z-index: 10;
      }

      /* Coluna de Controle e Log */
      #info-container {
        flex-basis: 50%;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      #controls {
        background: rgba(30, 30, 30, 0.7);
        backdrop-filter: blur(20px) saturate(180%);
        padding: 24px;
        border-radius: 16px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.1);
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      #controls button,
      #controls input,
      #controls label {
        font-family: "Inter", sans-serif;
        font-size: 15px;
        padding: 12px 16px;
        border-radius: 10px;
        font-weight: 600;
        letter-spacing: -0.022em;
      }

      .control-row {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .control-row label {
        color: rgba(255, 255, 255, 0.8);
        font-weight: 500;
        min-width: 70px;
        padding: 0;
      }

      #controls button {
        background: rgba(0, 122, 255, 0.9);
        color: white;
        border: none;
        cursor: pointer;
        transition: all 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        font-weight: 600;
        box-shadow: 0 4px 12px rgba(0, 122, 255, 0.25);
      }

      #controls button:hover:not(:disabled) {
        background: rgba(0, 122, 255, 1);
        transform: translateY(-1px);
        box-shadow: 0 6px 16px rgba(0, 122, 255, 0.35);
      }

      #controls button:disabled {
        background: rgba(255, 255, 255, 0.08);
        color: rgba(255, 255, 255, 0.3);
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      #controls input {
        width: 80px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        transition: all 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        color: rgba(255, 255, 255, 0.9);
        flex-shrink: 0;
      }

      #controls input:focus {
        outline: none;
        border-color: rgba(0, 122, 255, 0.6);
        box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.15);
        background: rgba(255, 255, 255, 0.08);
      }

      #controls button {
        flex: 1;
        min-width: 0;
      }

      #pointer-visual {
        font-family: "IBM Plex Mono", "SF Mono", "Monaco", "Menlo", monospace;
        font-size: 14px;
        font-weight: 500;
        background: rgba(0, 0, 0, 0.6);
        color: #00ff88;
        padding: 16px;
        border-radius: 10px;
        margin-top: 16px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        letter-spacing: -0.03em;
      }

      #log {
        background: rgba(30, 30, 30, 0.7);
        backdrop-filter: blur(20px) saturate(180%);
        height: 100%;
        overflow-y: auto;
        border: none;
        padding: 20px;
        font-family: "IBM Plex Mono", "SF Mono", "Monaco", "Menlo", monospace;
        border-radius: 16px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.1);
        font-size: 13px;
        font-weight: 400;
        line-height: 1.4;
        letter-spacing: -0.03em;
        flex: 1;
      }

      #log p {
        margin: 0 0 10px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        padding-bottom: 6px;
        color: rgba(255, 255, 255, 0.85);
      }

      #log p:has(> strong[style*="color: red"]) {
        color: rgba(255, 69, 58, 0.9);
      }

      /* Scrollbar styling */
      #log::-webkit-scrollbar {
        width: 4px;
      }

      #log::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 2px;
      }

      #log::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 2px;
      }

      #log::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.3);
      }
    </style>
  </head>
  <body>
    <div id="animation-container">
      <div id="ram-container">
        <h2>Simula√ß√£o de Mem√≥ria RAM (Bytes)</h2>
        <div id="ram"></div>
      </div>

      <div id="info-container">
        <h2>&nbsp;</h2>

        <div id="controls">
          <div class="control-row">
            <label for="array-size-input">Tamanho:</label>
            <input
              type="number"
              id="array-size-input"
              value="5"
              min="1"
              max="10"
            />
            <button id="alloc-btn">Alocar Array</button>
          </div>

          <div class="control-row">
            <label for="index-input">√çndice:</label>
            <input type="number" id="index-input" value="0" min="0" max="4" />
            <button id="access-btn" disabled>Buscar √çndice</button>
          </div>

          <div id="pointer-visual">meuArray = NULL;</div>
        </div>

        <div id="log">
          <p><strong>MEM√ìRIA RAM</strong></p>
          <p>‚Ä¢ Cada quadrado = 1 byte de mem√≥ria</p>
          <p>‚Ä¢ Endere√ßos hexadecimais (0x1000, 0x1001...)</p>
          <p>‚Ä¢ Array ocupa bytes consecutivos</p>
          <p>‚Ä¢ Acesso: endere√ßo_base + √≠ndice</p>
          <p>‚Ä¢ √çndices come√ßam em 0 (array[0] √© o primeiro)</p>
          <br />
          <p>Clique em "Alocar Array" para come√ßar...</p>
        </div>
      </div>
    </div>

    <script>
      // --- Configura√ß√µes Globais ---
      const RAM_SIZE = 24; // N√∫mero total de bytes na nossa RAM simulada
      let ARRAY_SIZE = 5; // Tamanho do nosso array (agora din√¢mico)
      const START_ADDRESS = 0x1000; // Endere√ßo de mem√≥ria inicial em hexadecimal
      // Cada c√©lula visual representa 1 byte
      // Endere√ßos: 0x1000, 0x1001, 0x1002, 0x1003, ... (incremento de 1 byte)

      // --- Estado da Aplica√ß√£o ---
      let arrayBaseAddress = null; // Onde o array foi alocado
      let allocatedBlocks = []; // Refer√™ncias para as c√©lulas do DOM

      // --- Refer√™ncias do DOM ---
      const ramContainer = document.getElementById("ram");
      const logContainer = document.getElementById("log");
      const allocBtn = document.getElementById("alloc-btn");
      const accessBtn = document.getElementById("access-btn");
      const indexInput = document.getElementById("index-input");
      const arraySizeInput = document.getElementById("array-size-input");
      const pointerVisual = document.getElementById("pointer-visual");

      // --- Fun√ß√µes Auxiliares ---

      /** Pausa a execu√ß√£o por um tempo (em ms) */
      const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

      /** Adiciona uma mensagem ao log */
      function logMessage(message) {
        console.log(message);
        logContainer.innerHTML += `<p>> ${message}</p>`;
        logContainer.scrollTop = logContainer.scrollHeight; // Rola para o final
      }

      /** Limpa destaques anteriores */
      function clearHighlights() {
        document.querySelectorAll(".memory-cell.highlighted").forEach((b) => {
          b.classList.remove("highlighted");
        });
      }

      /** Reseta a simula√ß√£o */
      function resetSimulation() {
        logMessage("Resetando simula√ß√£o de mem√≥ria...");
        arrayBaseAddress = null;
        allocatedBlocks = [];
        pointerVisual.textContent = "meuArray = NULL;";
        allocBtn.disabled = false;
        accessBtn.disabled = true;
        createRAM(); // Recria a RAM
      }

      /** Atualiza o limite m√°ximo do √≠ndice baseado no tamanho do array */
      function updateIndexLimit() {
        const newSize = parseInt(arraySizeInput.value);
        indexInput.max = newSize - 1;
        if (parseInt(indexInput.value) >= newSize) {
          indexInput.value = 0;
        }
      }

      // --- Fun√ß√µes Principais da Anima√ß√£o ---

      /** 1. Cria a representa√ß√£o visual da RAM */
      function createRAM() {
        ramContainer.innerHTML = ""; // Limpa a RAM antiga
        for (let i = 0; i < RAM_SIZE; i++) {
          const address = START_ADDRESS + i; // Incremento de 1 byte
          const block = document.createElement("div");

          // Primeiras 4 c√©lulas s√£o ocupadas pelo sistema
          if (i < 4) {
            block.className = "memory-cell system";
            block.innerHTML = `
                      <span class="address">0x${address
                        .toString(16)
                        .toUpperCase()}</span>
                      <span class="value">üì¶</span>
                  `;
          } else {
            block.className = "memory-cell free";
            block.innerHTML = `
                      <span class="address">0x${address
                        .toString(16)
                        .toUpperCase()}</span>
                      <span class="value">?</span>
                  `;
          }

          block.dataset.address = address;
          ramContainer.appendChild(block);
        }
      }

      /** 2. Anima√ß√£o de Aloca√ß√£o */
      async function handleAllocation() {
        // Atualiza o tamanho do array baseado no input
        ARRAY_SIZE = parseInt(arraySizeInput.value);

        resetSimulation(); // Reseta se j√° houver algo
        allocBtn.disabled = true;
        logMessage("<strong>MEM√ìRIA RAM - CONCEITOS FUNDAMENTAIS</strong>");
        logMessage("‚Ä¢ Array: bytes cont√≠guos | √çndices: 0 a N-1 | 24 bytes: alinhamento otimizado");
        await sleep(2000);
        logMessage(
          `Iniciando aloca√ß√£o de mem√≥ria para meuArray[${ARRAY_SIZE}] bytes...`
        );
        await sleep(1000);

        // Simula a busca por espa√ßo cont√≠guo.
        // O gerenciador de mem√≥ria busca c√©lulas livres consecutivas
        const startIndex = 4;
        const allCells = document.querySelectorAll(".memory-cell");

        logMessage(
          `Gerenciador de mem√≥ria encontrou ${ARRAY_SIZE} c√©lulas cont√≠guas livres...`
        );
        await sleep(1000);

        // Pega o endere√ßo base
        arrayBaseAddress = parseInt(allCells[startIndex].dataset.address);
        logMessage("<strong>ENDERE√áO BASE:</strong>");
        logMessage(
          `Primeiro byte do array: 0x${arrayBaseAddress
            .toString(16)
            .toUpperCase()}`
        );
        logMessage(
          `array[0] est√° em: 0x${arrayBaseAddress.toString(16).toUpperCase()}`
        );
        logMessage(
          `array[${ARRAY_SIZE - 1}] estar√° em: 0x${(
            arrayBaseAddress +
            ARRAY_SIZE -
            1
          )
            .toString(16)
            .toUpperCase()}`
        );
        pointerVisual.textContent = `meuArray = 0x${arrayBaseAddress
          .toString(16)
          .toUpperCase()};`;
        await sleep(500);

        logMessage("Alocando e inicializando o array com valores...");

        // Array de valores de exemplo (expandido para suportar mais tamanhos)
        const sampleValues = [
          "A1",
          "B2",
          "C3",
          "D4",
          "E5",
          "F6",
          "G7",
          "H8",
          "I9",
          "J0",
        ];

        for (let i = 0; i < ARRAY_SIZE; i++) {
          const cell = allCells[startIndex + i];
          const value = sampleValues[i % sampleValues.length];

          cell.classList.remove("free");
          cell.classList.add("allocated");
          cell.querySelector(".value").textContent = value;

          allocatedBlocks.push(cell); // Salva a refer√™ncia

          // Destaque r√°pido para mostrar a escrita
          cell.classList.add("highlighted");
          await sleep(400);
          cell.classList.remove("highlighted");
        }

        logMessage("Mem√≥ria alocada e array inicializado com sucesso.");
        accessBtn.disabled = false;
      }

      /** 3. Anima√ß√£o de Busca (Acesso) */
      async function handleAccess() {
        clearHighlights();
        accessBtn.disabled = true; // Desabilita durante a anima√ß√£o

        const index = parseInt(indexInput.value);

        // Valida√ß√£o
        if (index < 0 || index >= ARRAY_SIZE) {
          logMessage(
            `<strong>ERRO DE ACESSO:</strong> √çndice ${index} inv√°lido!`
          );
          logMessage(
            `Array tem ${ARRAY_SIZE} elementos: √≠ndices 0 a ${ARRAY_SIZE - 1}`
          );
          logMessage(`√çndice ${index} n√£o existe - lembre: come√ßa do ZERO!`);
          accessBtn.disabled = false;
          return;
        }

        logMessage(`Acessando posi√ß√£o de mem√≥ria meuArray[${index}]...`);
        await sleep(1000);

        logMessage("<strong>ARITM√âTICA DE ENDERE√áOS:</strong>");
        logMessage("C√°lculo: Endere√ßo = Endere√ßo Base + √çndice");
        logMessage(
          `Ex: array[0] = 0x${arrayBaseAddress.toString(16).toUpperCase()} + 0`
        );
        logMessage(
          `Ex: array[1] = 0x${arrayBaseAddress.toString(16).toUpperCase()} + 1`
        );
        await sleep(1500);

        const targetAddress = arrayBaseAddress + index;

        logMessage(
          `C√°lculo: 0x${targetAddress
            .toString(16)
            .toUpperCase()} = 0x${arrayBaseAddress
            .toString(16)
            .toUpperCase()} + ${index}`
        );
        await sleep(1500);

        // Encontra a c√©lula de mem√≥ria no DOM
        const targetCell = document.querySelector(
          `.memory-cell[data-address="${targetAddress}"]`
        );

        if (targetCell) {
          logMessage("<strong>ACESSO DIRETO:</strong>");
          logMessage(
            `Acessando byte individual em: 0x${targetAddress
              .toString(16)
              .toUpperCase()}`
          );
          targetCell.classList.add("highlighted");
          await sleep(1000);

          const value = targetCell.querySelector(".value").textContent;
          logMessage(
            `<strong>VALOR ENCONTRADO:</strong> ${value} na posi√ß√£o [${index}]`
          );
        } else {
          // Isso n√£o deve acontecer em nossa simula√ß√£o controlada
          logMessage(
            `ERRO: Endere√ßo 0x${targetAddress
              .toString(16)
              .toUpperCase()} n√£o encontrado!`
          );
        }

        accessBtn.disabled = false; // Reabilita o bot√£o
      }

      // --- Inicializa√ß√£o ---
      document.addEventListener("DOMContentLoaded", () => {
        createRAM();
        allocBtn.addEventListener("click", handleAllocation);
        accessBtn.addEventListener("click", handleAccess);
        arraySizeInput.addEventListener("input", updateIndexLimit);
        updateIndexLimit(); // Configura limite inicial
      });
    </script>
  </body>
</html>
